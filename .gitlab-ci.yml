# GitLab CI/CD Pipeline for MAAS Frontend
# Triggers on Git tags (e.g., v1.0.0, v1.2.3) for production releases

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  # Enable BuildKit for faster builds and caching
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain
  # Image registry - separate repos for pulling base images vs pushing built images
  IMAGE_NAME: maas-front
  IMAGE_TAG: ${CI_COMMIT_TAG}
  # NEXUS_BUILD_REGISTRY - for pulling base images during build (e.g., vortex.kronshtadt.ru:8443)
  # NEXUS_PUSH_REGISTRY - for pushing final built images (e.g., nexus.maas.int.kronshtadt.ru:8443)
  NEXUS_PUSH_IMAGE: ${NEXUS_PUSH_REGISTRY}/maas-hosted/${IMAGE_NAME}

stages:
  - build
  - deploy

# Build Docker image and push to Nexus registry
build:
  stage: build
  image: ${NEXUS_BUILD_REGISTRY}/maas-proxy/${DOCKER_IMAGE}
  services:
    - name: ${NEXUS_BUILD_REGISTRY}/maas-proxy/docker:28.4.0-dind # Enable Docker-in-Docker
      command: ["--insecure-registry=$NEXUS_BUILD_REGISTRY"]
  cache:
    key: 
      files:
        - package-lock.json
    paths:
      - node_modules/
      - .npm/
    policy: pull-push
  before_script:
    # Login to Nexus build registry (for pulling base images)
    - echo $NEXUS_BUILD_PASSWORD | docker login -u $NEXUS_BUILD_USER --password-stdin $NEXUS_BUILD_REGISTRY
    # Login to Nexus push registry (for pushing built images)
    - echo $NEXUS_PUSH_PASSWORD | docker login -u $NEXUS_PUSH_USER --password-stdin $NEXUS_PUSH_REGISTRY
    # Try to pull previous image for cache (ignore if not found)
    - docker pull $NEXUS_PUSH_IMAGE:latest || true
  script:
    # Build image with private registry credentials and cache
    - |
      docker build -f Dockerfile.prod \
        --build-arg NPM_REGISTRY=$NPM_REGISTRY \
        --build-arg NPM_AUTH=$NPM_AUTH \
        --build-arg NODE_IMAGE=$NODE_IMAGE \
        --build-arg NGINX_IMAGE=$NGINX_IMAGE \
        --build-arg APT_PROXY=$APT_PROXY \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg GIT_TAG=$CI_COMMIT_TAG \
        --build-arg GIT_HASH=$CI_COMMIT_SHA \
        --build-arg GIT_BRANCH=$CI_COMMIT_REF_NAME \
        --cache-from $NEXUS_PUSH_IMAGE:latest \
        -t $NEXUS_PUSH_IMAGE:$IMAGE_TAG \
        -t $NEXUS_PUSH_IMAGE:latest .
    # Push both tags to Nexus push registry
    - docker push $NEXUS_PUSH_IMAGE:$IMAGE_TAG
    - docker push $NEXUS_PUSH_IMAGE:latest
    # Clean up local images
    - docker rmi $NEXUS_PUSH_IMAGE:$IMAGE_TAG $NEXUS_PUSH_IMAGE:latest || true
  only:
    - tags
  tags:
    - maas

# Deploy to remote production server
deploy:
  stage: deploy
  image: ${NEXUS_PUSH_REGISTRY}/maas-hosted/maas-deploy-tools:latest
  before_script:
    # Setup SSH key (tools already pre-installed in custom image)
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -p $SSH_PORT $SSH_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - scp -P $SSH_PORT docker-compose.yml $SSH_USER@$SSH_HOST:$REMOTE_PROJECT_PATH/
    # Deploy to remote server
    - |
      ssh -p $SSH_PORT $SSH_USER@$SSH_HOST << EOF
        set -e
        
        echo "ðŸš€ Starting deployment process..."
        echo "Current directory: $(pwd)"
        echo "Target directory: ${REMOTE_PROJECT_PATH}"
        
        # Check if project directory exists, create if not
        if [ ! -d "${REMOTE_PROJECT_PATH}" ]; then
          echo "ðŸ“ Project directory does not exist, creating it..."
          sudo mkdir -p ${REMOTE_PROJECT_PATH}
          sudo chown ${SSH_USER}:${SSH_USER} "${REMOTE_PROJECT_PATH}"
          echo "âœ… Created project directory and chowned: ${REMOTE_PROJECT_PATH}"
        else
          echo "âœ… Project directory exists: ${REMOTE_PROJECT_PATH}"
        fi
        
        # Navigate to project directory
        cd ${REMOTE_PROJECT_PATH}
        echo "âœ… Changed to project directory: ${REMOTE_PROJECT_PATH}"
        
        # Create/update .env.production
        echo "ðŸ“ Creating .env.production file..."
        echo "VITE_API_BASE=${VITE_API_BASE}" > .env.production
        echo "VITE_BASE_PATH=${VITE_BASE_PATH}" >> .env.production
        echo "âœ… .env.production created with content:"
        cat .env.production
        
        # Login to Nexus push registry
        echo "ðŸ” Logging into Nexus registry..."
        echo ${NEXUS_PUSH_PASSWORD} | docker login -u ${NEXUS_PUSH_USER} --password-stdin ${NEXUS_PUSH_REGISTRY}
        echo "âœ… Successfully logged into Nexus registry"
        
        # Update docker-compose.yml image tag
        echo "ðŸ”„ Updating docker-compose.yml with new image tag..."
        sed -i "s|image:.*maas-front:.*|image: ${NEXUS_PUSH_IMAGE}:${IMAGE_TAG}|g" docker-compose.yml
        echo "âœ… Updated docker-compose.yml"
        echo "New image: ${NEXUS_PUSH_IMAGE}:${IMAGE_TAG}"
        
        # Pull new image
        echo "ðŸ“¥ Pulling new Docker image..."
        sudo docker compose pull
        echo "âœ… Image pulled successfully"
        
        # Stop and remove old container
        echo "ðŸ›‘ Stopping old container..."
        sudo docker compose down || true
        echo "âœ… Old container stopped"
        
        # Start new container
        echo "ðŸš€ Starting new container..."
        sudo docker compose up -d
        echo "âœ… New container started"
        
        # Verify deployment
        sleep 10
        
        # Check container status
        if docker compose ps | grep -q "Up"; then
          echo "âœ… Container is running"
        else
          echo "âŒ Container is not running"
          sudo docker compose logs
          exit 1
        fi
        
        # Check if application is responding
        CONTAINER_NAME=$(sudo docker compose ps -q)
        if [ -n "$CONTAINER_NAME" ]; then
          # Wait for application to be ready
          for i in {1..30}; do
            if sudo docker exec $CONTAINER_NAME curl -f http://localhost:80/health 2>/dev/null; then
              echo "âœ… Application health check passed"
              break
            elif [ $i -eq 30 ]; then
              echo "âŒ Application health check failed after 30 attempts"
              sudo docker compose logs
              exit 1
            else
              echo "Waiting for application to be ready... ($i/30)"
              sleep 2
            fi
          done
        fi
        
        # Log deployment info
        echo "âœ… Deployment successful"
        echo "Image: ${NEXUS_PUSH_IMAGE}:${IMAGE_TAG}"
        echo "Container status:"
        sudo docker compose ps
        echo "Container logs (last 20 lines):"
        sudo docker compose logs --tail=20
        
        # Create deployment marker file
        echo "Deployment completed at $(date)" > deployment.log
        echo "Image: ${NEXUS_PUSH_IMAGE}:${IMAGE_TAG}" >> deployment.log
        echo "Git tag: ${IMAGE_TAG}" >> deployment.log
        echo "Git commit: ${CI_COMMIT_SHA}" >> deployment.log
      EOF
  only:
    - tags
  dependencies:
    - build
  tags:
    - maas
